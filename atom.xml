<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学习使人进步-( ゜- ゜)つロ干杯~</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://seriouszyx.github.io/"/>
  <updated>2019-03-13T05:32:06.000Z</updated>
  <id>https://seriouszyx.github.io/</id>
  
  <author>
    <name>Xin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IoC容器浅析及简单实现</title>
    <link href="https://seriouszyx.github.io/2018/11/25/IoC%E5%AE%B9%E5%99%A8%E6%B5%85%E6%9E%90%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0.html"/>
    <id>https://seriouszyx.github.io/2018/11/25/IoC容器浅析及简单实现.html</id>
    <published>2018-11-25T06:43:04.000Z</published>
    <updated>2019-03-13T05:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring IoC 容器是 Spring 框架中最核心的部分，也是初学者难以理解的部分，对于这种关键的设计，简单实现一次能最大限度地加深理解，了解其中思想，对以后的开发也大有裨益。</p><a id="more"></a><h1 id="Spring-IoC-容器浅析及简单实现"><a href="#Spring-IoC-容器浅析及简单实现" class="headerlink" title="Spring IoC 容器浅析及简单实现"></a>Spring IoC 容器浅析及简单实现</h1><h2 id="Spring-IoC-概述"><a href="#Spring-IoC-概述" class="headerlink" title="Spring IoC 概述"></a>Spring IoC 概述</h2><p>原生的 JavaEE 技术中各个模块之间的联系较强，即<code>耦合度较高</code>。</p><p>比如完成一个用户的创建事务，视图层会创建业务逻辑层的对象，再在内部调用对象的方法，各个模块的<code>独立性很差</code>，如果某一模块的代码发生改变，其他模块的改动也会很大。</p><p>而 Spring 框架的核心——IoC（控制反转）很好的解决了这一问题。控制反转，即<code>某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定</code>，即由 Spring 容器借由 Bean 配置来进行控制。</p><p>可能 IoC 不够开门见山，理解起来较为困难。因此， Martin Fowler 提出了 DI（Dependency Injection，依赖注入）的概念来替代 IoC，即<code>让调用类对某一接口实现类的依赖关系由第三方（容器或写协作类）注入，以移除调用类对某一接口实现类的依赖</code>。</p><p>比如说， 上述例子中，视图层使用业务逻辑层的接口变量，而不需要真正 new 出接口的实现，这样即使接口产生了新的实现或原有实现修改，视图层都能正常运行。</p><p>从注入方法上看，IoC 主要划分为三种类型：构造函数注入、属性注入和接口注入。在开发过程中，一般使用<code>属性注入</code>的方法。</p><p>IoC 不仅可以实现<code>类之间的解耦</code>，还能帮助完成<code>类的初始化与装配工作</code>，让开发者从这些底层实现类的实例化、依赖关系装配等工作中解脱出出来，专注于更有意义的业务逻辑开发工作。</p><h2 id="Spring-IoC-简单实现"><a href="#Spring-IoC-简单实现" class="headerlink" title="Spring IoC 简单实现"></a>Spring IoC 简单实现</h2><p>下面实现了一个IoC容器的核心部分，简单模拟了IoC容器的基本功能。</p><p>下面列举出核心类：</p><p>Student.java</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * @ClassName Student * @Description 学生实体类 * @Author Yixiang Zhao * @Date 2018/9/22 9:19 * @Version 1.0 */public class Student {    private String name;    private String gender;    public void intro() {        System.out.println("My name is " + name + " and I'm " + gender + " .");    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getGender() {        return gender;    }    public void setGender(String gender) {        this.gender = gender;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>StuService.java</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * @ClassName StuService * @Description 学生Service * @Author Yixiang Zhao * @Date 2018/9/22 9:21 * @Version 1.0 */public class StuService {    private Student student;    public Student getStudent() {        return student;    }    public void setStudent(Student student) {        this.student = student;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>beans.xml</p><pre class="line-numbers language-lang-xml"><code class="language-lang-xml"><?xml version="1.0" encoding="UTF-8"?><beans>    <bean id="Student" class="me.seriouszyx.pojo.Student">        <property name="name" value="ZYX"/>        <property name="gender" value="man"/>    </bean>    <bean id="StuService" class="me.seriouszyx.service.StuService">        <property ref="Student"/>    </bean></beans><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面是核心类 ClassPathXMLApplicationContext.java</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">/** * @ClassName ClassPathXMLApplicationContext * @Description ApplicationContext的实现，核心类 * @Author Yixiang Zhao * @Date 2018/9/22 9:40 * @Version 1.0 */public class ClassPathXMLApplicationContext implements ApplicationContext {    private Map map = new HashMap();    public ClassPathXMLApplicationContext(String location) {        try {            Document document = getDocument(location);            XMLParsing(document);        } catch (Exception e) {            e.printStackTrace();        }    }    // 加载资源文件，转换成Document类型    private Document getDocument(String location) throws JDOMException, IOException {        SAXBuilder saxBuilder = new SAXBuilder();        return saxBuilder.build(this.getClass().getClassLoader().getResource(location));    }    private void XMLParsing(Document document) throws Exception {        // 获取XML文件根元素beans        Element beans = document.getRootElement();        // 获取beans下的bean集合        List beanList = beans.getChildren("bean");        // 遍历beans集合        for (Iterator iter = beanList.iterator(); iter.hasNext(); ) {            Element bean = (Element) iter.next();            // 获取bean的属性id和class，id为类的key值，class为类的路径            String id = bean.getAttributeValue("id");            String className = bean.getAttributeValue("class");            // 动态加载该bean代表的类            Object obj = Class.forName(className).newInstance();            // 获得该类的所有方法            Method[] methods = obj.getClass().getDeclaredMethods();            // 获取该节点的所有子节点，子节点存储类的初始化参数            List<Element> properties = bean.getChildren("property");            // 遍历，将初始化参数和类的方法对应，进行类的初始化            for (Element pro : properties) {                for (int i = 0; i < methods.length; i++) {                    String methodName = methods[i].getName();                    if (methodName.startsWith("set")) {                        String classProperty = methodName.substring(3, methodName.length()).toLowerCase();                        if (pro.getAttribute("name") != null) {                            if (classProperty.equals(pro.getAttribute("name").getValue())) {                                methods[i].invoke(obj, pro.getAttribute("value").getValue());                            }                        } else {                            methods[i].invoke(obj, map.get(pro.getAttribute("ref").getValue()));                        }                    }                }            }            // 将初始化完成的对象添加到HashMap中            map.put(id, obj);        }    }    public Object getBean(String name) {        return map.get(name);    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后进行测试</p><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class MyIoCTest {    public static void main(String[] args) {        ApplicationContext context = new ClassPathXMLApplicationContext("beans.xml");        StuService stuService = (StuService) context.getBean("StuService");        stuService.getStudent().intro();    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试成功！</p><pre class="line-numbers language-lang-text"><code class="language-lang-text">My name is ZYX and I'm man .Process finished with exit code 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>代码在我的 <a href="https://github.com/seriouszyx/LearnSpring/tree/master/mycode/SimpleIoC" target="_blank" rel="noopener">GitHub</a>开源，欢迎一起交流讨论。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>熟悉一个框架最好的方式，就是亲手实现它。这样不仅会深刻地认识到框架的工作原理，以后的使用也会更加得心应手。</p><p>此外，在实现的过程中，又会收获很多东西，就像实现 IoC 容器一样，不仅了解解析 XML 文件的 JDOM 工具，还加深了对 Java 反射的理解。在实际开发中，几乎没有任何地方需要用到反射这一技术，但在框架实现过程中，不懂反射则寸步难行。</p><blockquote><p>   更多的 Spring 学习心得请戳<a href="https://github.com/seriouszyx/LearnSpring" target="_blank" rel="noopener">Spring 框架学习</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring IoC 容器是 Spring 框架中最核心的部分，也是初学者难以理解的部分，对于这种关键的设计，简单实现一次能最大限度地加深理解，了解其中思想，对以后的开发也大有裨益。&lt;/p&gt;
    
    </summary>
    
      <category term="知识总结" scheme="https://seriouszyx.github.io/categories/%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="JavaWeb" scheme="https://seriouszyx.github.io/tags/JavaWeb/"/>
    
      <category term="Java" scheme="https://seriouszyx.github.io/tags/Java/"/>
    
  </entry>
  
</feed>
