[{"url":"%2F2019%2F03%2F16%2FIoC%E5%AE%B9%E5%99%A8%E6%B5%85%E6%9E%90%E5%8F%8A%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0.html","content":"---\rlayout: spring\rtitle: IoC容器浅析及简单实现\rdate: 2018-11-25 14:43:04\rcategories:\r- 知识总结\rtags:\r- JavaWeb\r- Java\rcopyright: true\r---\r\rSpring IoC 容器是 Spring 框架中最核心的部分，也是初学者难以理解的部分，对于这种关键的设计，简单实现一次能最大限度地加深理解，了解其中思想，对以后的开发也大有裨益。\r\r\r\r<!-- more -->\r\r#   Spring IoC 容器浅析及简单实现\r\r\r##\tSpring IoC 概述\r\r原生的 JavaEE 技术中各个模块之间的联系较强，即`耦合度较高`。\r\r比如完成一个用户的创建事务，视图层会创建业务逻辑层的对象，再在内部调用对象的方法，各个模块的`独立性很差`，如果某一模块的代码发生改变，其他模块的改动也会很大。\r\r而 Spring 框架的核心——IoC（控制反转）很好的解决了这一问题。控制反转，即`某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定`，即由 Spring 容器借由 Bean 配置来进行控制。\r\r可能 IoC 不够开门见山，理解起来较为困难。因此， Martin Fowler 提出了 DI（Dependency Injection，依赖注入）的概念来替代 IoC，即`让调用类对某一接口实现类的依赖关系由第三方（容器或写协作类）注入，以移除调用类对某一接口实现类的依赖`。\r\r比如说， 上述例子中，视图层使用业务逻辑层的接口变量，而不需要真正 new 出接口的实现，这样即使接口产生了新的实现或原有实现修改，视图层都能正常运行。\r\r从注入方法上看，IoC 主要划分为三种类型：构造函数注入、属性注入和接口注入。在开发过程中，一般使用`属性注入`的方法。\r\rIoC 不仅可以实现`类之间的解耦`，还能帮助完成`类的初始化与装配工作`，让开发者从这些底层实现类的实例化、依赖关系装配等工作中解脱出出来，专注于更有意义的业务逻辑开发工作。\r\r##\tSpring IoC 简单实现\r\r下面实现了一个IoC容器的核心部分，简单模拟了IoC容器的基本功能。\r\r\r下面列举出核心类：\r\rStudent.java\r\r```java\r/**\r * @ClassName Student\r * @Description 学生实体类\r * @Author Yixiang Zhao\r * @Date 2018/9/22 9:19\r * @Version 1.0\r */\rpublic class Student {\r\r    private String name;\r\r    private String gender;\r\r    public void intro() {\r        System.out.println(\"My name is \" + name + \" and I'm \" + gender + \" .\");\r    }\r\r    public String getName() {\r        return name;\r    }\r\r    public void setName(String name) {\r        this.name = name;\r    }\r\r    public String getGender() {\r        return gender;\r    }\r\r    public void setGender(String gender) {\r        this.gender = gender;\r    }\r}\r```\r\rStuService.java\r\r```java\r/**\r * @ClassName StuService\r * @Description 学生Service\r * @Author Yixiang Zhao\r * @Date 2018/9/22 9:21\r * @Version 1.0\r */\rpublic class StuService {\r\r    private Student student;\r\r    public Student getStudent() {\r        return student;\r    }\r\r    public void setStudent(Student student) {\r        this.student = student;\r    }\r}\r```\r\rbeans.xml\r\r```xml\r<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\r<beans>\r    <bean id=\"Student\" class=\"me.seriouszyx.pojo.Student\">\r        <property name=\"name\" value=\"ZYX\"/>\r        <property name=\"gender\" value=\"man\"/>\r    </bean>\r\r    <bean id=\"StuService\" class=\"me.seriouszyx.service.StuService\">\r        <property ref=\"Student\"/>\r    </bean>\r</beans>\r```\r\r下面是核心类 ClassPathXMLApplicationContext.java\r\r```java\r\r/**\r * @ClassName ClassPathXMLApplicationContext\r * @Description ApplicationContext的实现，核心类\r * @Author Yixiang Zhao\r * @Date 2018/9/22 9:40\r * @Version 1.0\r */\rpublic class ClassPathXMLApplicationContext implements ApplicationContext {\r\r    private Map map = new HashMap();\r\r    public ClassPathXMLApplicationContext(String location) {\r        try {\r            Document document = getDocument(location);\r            XMLParsing(document);\r        } catch (Exception e) {\r            e.printStackTrace();\r        }\r    }\r\r    // 加载资源文件，转换成Document类型\r    private Document getDocument(String location) throws JDOMException, IOException {\r        SAXBuilder saxBuilder = new SAXBuilder();\r        return saxBuilder.build(this.getClass().getClassLoader().getResource(location));\r    }\r\r    private void XMLParsing(Document document) throws Exception {\r        // 获取XML文件根元素beans\r        Element beans = document.getRootElement();\r        // 获取beans下的bean集合\r        List beanList = beans.getChildren(\"bean\");\r        // 遍历beans集合\r        for (Iterator iter = beanList.iterator(); iter.hasNext(); ) {\r            Element bean = (Element) iter.next();\r            // 获取bean的属性id和class，id为类的key值，class为类的路径\r            String id = bean.getAttributeValue(\"id\");\r            String className = bean.getAttributeValue(\"class\");\r            // 动态加载该bean代表的类\r            Object obj = Class.forName(className).newInstance();\r            // 获得该类的所有方法\r            Method[] methods = obj.getClass().getDeclaredMethods();\r            // 获取该节点的所有子节点，子节点存储类的初始化参数\r            List<Element> properties = bean.getChildren(\"property\");\r            // 遍历，将初始化参数和类的方法对应，进行类的初始化\r            for (Element pro : properties) {\r                for (int i = 0; i < methods.length; i++) {\r                    String methodName = methods[i].getName();\r                    if (methodName.startsWith(\"set\")) {\r                        String classProperty = methodName.substring(3, methodName.length()).toLowerCase();\r                        if (pro.getAttribute(\"name\") != null) {\r                            if (classProperty.equals(pro.getAttribute(\"name\").getValue())) {\r                                methods[i].invoke(obj, pro.getAttribute(\"value\").getValue());\r                            }\r                        } else {\r                            methods[i].invoke(obj, map.get(pro.getAttribute(\"ref\").getValue()));\r                        }\r                    }\r                }\r            }\r            // 将初始化完成的对象添加到HashMap中\r            map.put(id, obj);\r        }\r    }\r\r    public Object getBean(String name) {\r        return map.get(name);\r    }\r\r}\r```\r\r最后进行测试\r\r```java\rpublic class MyIoCTest {\r    public static void main(String[] args) {\r        ApplicationContext context = new ClassPathXMLApplicationContext(\"beans.xml\");\r        StuService stuService = (StuService) context.getBean(\"StuService\");\r        stuService.getStudent().intro();\r    }\r}\r```\r\r测试成功！\r\r```text\rMy name is ZYX and I'm man .\r\rProcess finished with exit code 0\r```\r\r##\t源码\r\r代码在我的 [GitHub](https://github.com/seriouszyx/LearnSpring/tree/master/mycode/SimpleIoC)开源，欢迎一起交流讨论。\r\r##\t总结\r\r熟悉一个框架最好的方式，就是亲手实现它。这样不仅会深刻地认识到框架的工作原理，以后的使用也会更加得心应手。\r\r此外，在实现的过程中，又会收获很多东西，就像实现 IoC 容器一样，不仅了解解析 XML 文件的 JDOM 工具，还加深了对 Java 反射的理解。在实际开发中，几乎没有任何地方需要用到反射这一技术，但在框架实现过程中，不懂反射则寸步难行。\r\r\r"}]